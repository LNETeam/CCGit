{"ts":1373049121036,"silentsave":true,"restoring":false,"patch":[[]],"length":0}
{"contributors":[],"silentsave":false,"ts":1373049216255,"patch":[[{"diffs":[[1,"function get(auth,rep,bran,paths,sN)\n\nend\n\nfunction view(auth,rep,bran,paths)\n\nend\n\nlocal function edit(file)"]],"start1":0,"start2":0,"length1":0,"length2":109}]],"length":109,"saved":false}
{"contributors":[],"silentsave":false,"ts":1373049586448,"patch":[[{"diffs":[[1,"\n\nlocal "],[0,"function get(aut"]],"start1":0,"start2":0,"length1":16,"length2":24},{"diffs":[[0,"ion "],[-1,"get(auth,rep,bran,paths,sN)\n\nend\n\nfunction view(auth,rep,bran,paths)\n\nend\n\nlocal function edit(file)"],[1,"edit(file)\n    tArgs[1] = path\n\n-- Error checking\nlocal sPath = shell.resolve( tArgs[1] )\n\nlocal x,y = 1,1\nlocal w,h = term.getSize()\nlocal scrollX, scrollY = 0,0\n\nlocal tLines = {}\nlocal bRunning = true\n\n-- Colours\nlocal highlightColour, keywordColour, commentColour, textColour, bgColour\nif term.isColour() then\n    bgColour = colours.black\n    textColour = colours.white\n    highlightColour = colours.yellow\n    keywordColour = colours.yellow\n    commentColour = colours.lime\n    stringColour = colours.red\nelse\n    bgColour = colours.black\n    textColour = colours.white\n    highlightColour = colours.white\n    keywordColour = colours.white\n    commentColour = colours.white\n    stringColour = colours.white\nend\n\n-- Menus\nlocal bMenu = false\nlocal nMenuItem = 1\nlocal tMenuItems = {\"Exit\", \"Print\"}\nlocal sStatus = \"Press Ctrl to access menu\"\n\nlocal function load(_sPath)\n    tLines = {}\n    if fs.exists( _sPath ) then\n        local file = io.open( _sPath, \"r\" )\n        local sLine = file:read()\n        while sLine do\n            table.insert( tLines, sLine )\n            sLine = file:read()\n        end\n        file:close()\n    end\n    \n    if #tLines == 0 then\n        table.insert( tLines, \"\" )\n    end\nend\n\nlocal function save( _sPath )\n    -- Create intervening folder\n    local sDir = sPath:sub(1, sPath:len() - fs.getName(sPath):len() )\n    if not fs.exists( sDir ) then\n        fs.makeDir( sDir )\n    end\n\n    -- Save\n    local file = nil\n    local function innerSave()\n        file = fs.open( _sPath, \"w\" )\n        if file then\n            for n, sLine in ipairs( tLines ) do\n                file.write( sLine .. \"\\n\" )\n            end\n        else\n            error( \"Failed to open \".._sPath )\n        end\n    end\n    \n    local ok = pcall( innerSave )\n    if file then \n        file.close()\n    end\n    return ok\nend\n\nlocal tKeywords = {\n    [\"and\"] = true,\n    [\"break\"] = true,\n    [\"do\"] = true,\n    [\"else\"] = true,\n    [\"elseif\"] = true,\n    [\"end\"] = true,\n    [\"false\"] = true,\n    [\"for\"] = true,\n    [\"function\"] = true,\n    [\"if\"] = true,\n    [\"in\"] = true,\n    [\"local\"] = true,\n    [\"nil\"] = true,\n    [\"not\"] = true,\n    [\"or\"] = true,\n    [\"repeat\"] = true,\n    [\"return\"] = true,\n    [\"then\"] = true,\n    [\"true\"] = true,\n    [\"until\"]= true,\n    [\"while\"] = true,\n}\n\nlocal function tryWrite( sLine, regex, colour )\n    local match = string.match( sLine, regex )\n    if match then\n        if type(colour) == \"number\" then\n            term.setTextColour( colour )\n        else\n            term.setTextColour( colour(match) )\n        end\n        term.write( match )\n        term.setTextColour( textColour )\n        return string.sub( sLine, string.len(match) + 1 )\n    end\n    return nil\nend\n\nlocal function writeHighlighted( sLine )\n    while string.len(sLine) > 0 do  \n        sLine = \n            tryWrite( sLine, \"^%-%-%[%[.-%]%]\", commentColour ) or\n            tryWrite( sLine, \"^%-%-.*\", commentColour ) or\n            tryWrite( sLine, \"^\\\".-[^\\\\]\\\"\", stringColour ) or\n            tryWrite( sLine, \"^\\'.-[^\\\\]\\'\", stringColour ) or\n            tryWrite( sLine, \"^%[%[.-%]%]\", stringColour ) or\n            tryWrite( sLine, \"^[%w_]+\", function( match )\n                if tKeywords[ match ] then\n                    return keywordColour\n                end\n                return textColour\n            end ) or\n            tryWrite( sLine, \"^[^%w_]\", textColour )\n    end\nend\n\nlocal function redrawText()\n    for y=1,h-1 do\n        term.setCursorPos( 1 - scrollX, y )\n        term.clearLine()\n\n        local sLine = tLines[ y + scrollY ]\n        if sLine ~= nil then\n            writeHighlighted( sLine )\n        end\n    end\n    term.setCursorPos( x - scrollX, y - scrollY )\nend\n\nlocal function redrawLine(_nY)\n    local sLine = tLines[_nY]\n    term.setCursorPos( 1 - scrollX, _nY - scrollY )\n    term.clearLine()\n    writeHighlighted( sLine )\n    term.setCursorPos( x - scrollX, _nY - scrollY )\nend\n\nlocal function setLeftStatus()\nend\n\nlocal function redrawMenu()\n    term.setCursorPos( 1, h )\n    term.clearLine()\n\n    local sLeft, sRight\n    local nLeftColour, nLeftHighlight1, nLeftHighlight2\n    if bMenu then\n        local sMenu = \"\"\n        for n,sItem in ipairs( tMenuItems ) do\n            if n == nMenuItem then\n                nLeftHighlight1 = sMenu:len() + 1\n                nLeftHighlight2 = sMenu:len() + sItem:len() + 2\n            end\n            sMenu = sMenu..\" \"..sItem..\" \"\n        end\n        sLeft = sMenu\n        nLeftColour = textColour\n    else\n        sLeft = sStatus\n        nLeftColour = highlightColour\n    end\n    \n    -- Left goes last so that it can overwrite the line numbers.\n    sRight = \"Ln \"..y\n    term.setTextColour( highlightColour )\n    term.setCursorPos( w-sRight:len() + 1, h )\n    term.write(sRight)\n\n    sRight = tostring(y)\n    term.setTextColour( textColour )\n    term.setCursorPos( w-sRight:len() + 1, h )\n    term.write(sRight)\n\n    if sLeft then\n        term.setCursorPos( 1, h )\n        term.setTextColour( nLeftColour )\n        term.write(sLeft)       \n        if nLeftHighlight1 then\n            term.setTextColour( highlightColour )\n            term.setCursorPos( nLeftHighlight1, h )\n            term.write( \"[\" )\n            term.setCursorPos( nLeftHighlight2, h )\n            term.write( \"]\" )\n        end\n        term.setTextColour( textColour )\n    end\n    \n    -- Cursor highlights selection\n    term.setCursorPos( x - scrollX, y - scrollY )\nend\n\nlocal tMenuFuncs = { \n    Save=function()\n        if bReadOnly then\n            sStatus = \"Access denied\"\n        else\n            local ok, err = save( sPath )\n            if ok then\n                sStatus=\"Saved to \"..sPath\n            else\n                sStatus=\"Error saving to \"..sPath\n            end\n        end\n        redrawMenu()\n    end,\n    Print=function()\n        local sPrinterSide = nil\n        for n,sSide in ipairs(rs.getSides()) do\n            if peripheral.isPresent(sSide) and peripheral.getType(sSide) == \"printer\" then\n                sPrinterSide = sSide\n                break\n            end\n        end\n        \n        if not sPrinterSide then\n            sStatus = \"No printer attached\"\n            return\n        end\n\n        local nPage = 0\n        local sName = fs.getName( sPath )\n        local printer = peripheral.wrap(sPrinterSide)\n        if printer.getInkLevel() < 1 then\n            sStatus = \"Printer out of ink\"\n            return\n        elseif printer.getPaperLevel() < 1 then\n            sStatus = \"Printer out of paper\"\n            return\n        end\n        \n        local terminal = {\n            getCursorPos = printer.getCursorPos,\n            setCursorPos = printer.setCursorPos,\n            getSize = printer.getPageSize,\n            write = printer.write,\n        }\n        terminal.scroll = function()\n            if nPage == 1 then\n                printer.setPageTitle( sName..\" (page \"..nPage..\")\" )            \n            end\n            \n            while not printer.newPage() do\n                if printer.getInkLevel() < 1 then\n                    sStatus = \"Printer out of ink, please refill\"\n                elseif printer.getPaperLevel() < 1 then\n                    sStatus = \"Printer out of paper, please refill\"\n                else\n                    sStatus = \"Printer output tray full, please empty\"\n                end\n    \n                term.restore()\n                redrawMenu()\n                term.redirect( terminal )\n                \n                local timer = os.startTimer(0.5)\n                sleep(0.5)\n            end\n\n            nPage = nPage + 1\n            if nPage == 1 then\n                printer.setPageTitle( sName )\n            else\n                printer.setPageTitle( sName..\" (page \"..nPage..\")\" )\n            end\n        end\n        \n        bMenu = false\n        term.redirect( terminal )\n        local ok, error = pcall( function()\n            term.scroll()\n            for n, sLine in ipairs( tLines ) do\n                print( sLine )\n            end\n        end )\n        term.restore()\n        if not ok then\n            print( error )\n        end\n        \n        while not printer.endPage() do\n            sStatus = \"Printer output tray full, please empty\"\n            redrawMenu()\n            sleep( 0.5 )\n        end\n        bMenu = true\n            \n        if nPage > 1 then\n            sStatus = \"Printed \"..nPage..\" Pages\"\n        else\n            sStatus = \"Printed 1 Page\"\n        end\n        redrawMenu()\n    end,\n    Exit=function()\n        bRunning = false\n    end\n}\n\nlocal function doMenuItem( _n )\n    tMenuFuncs[tMenuItems[_n]]()\n    if bMenu then\n        bMenu = false\n        term.setCursorBlink( true )\n    end\n    redrawMenu()\nend\n\nlocal function setCursor( x, y )\n    local screenX = x - scrollX\n    local screenY = y - scrollY\n    \n    local bRedraw = false\n    if screenX < 1 then\n        scrollX = x - 1\n        screenX = 1\n        bRedraw = true\n    elseif screenX > w then\n        scrollX = x - w\n        screenX = w\n        bRedraw = true\n    end\n    \n    if screenY < 1 then\n        scrollY = y - 1\n        screenY = 1\n        bRedraw = true\n    elseif screenY > h-1 then\n        scrollY = y - (h-1)\n        screenY = h-1\n        bRedraw = true\n    end\n    \n    if bRedraw then\n        redrawText()\n    end\n    term.setCursorPos( screenX, screenY )\n    \n    -- Statusbar now pertains to menu, it would probably be safe to redraw the menu on every key event.\n    redrawMenu()\nend\n\n-- Actual program functionality begins\nload(sPath)\n\nterm.setBackgroundColour( bgColour )\nterm.clear()\nterm.setCursorPos(x,y)\nterm.setCursorBlink( true )\n\nredrawText()\nredrawMenu()\n\n-- Handle input\nwhile bRunning do\n    local sEvent, param, param2, param3 = os.pullEvent()\n    if sEvent == \"key\" then\n        if param == keys.up then\n            -- Up\n            if not bMenu then\n                if y > 1 then\n                    -- Move cursor up\n                    y = y - 1\n                    x = math.min( x, string.len( tLines[y] ) + 1 )\n                    setCursor( x, y )\n                end\n            end\n        elseif param == keys.down then\n            -- Down\n            if not bMenu then\n                -- Move cursor down\n                if y < #tLines then\n                    y = y + 1\n                    x = math.min( x, string.len( tLines[y] ) + 1 )\n                    setCursor( x, y )\n                end\n            end\n        elseif param == keys.tab then\n            -- Tab\n            if not bMenu then\n                local sLine = tLines[y]\n\n                -- Indent line\n                -- IN CASE OF INSERT TAB IN PLACE:\n                -- tLines[y] = string.sub(sLine,1,x-1) .. \"  \" .. string.sub(sLine,x)\n                tLines[y]=\"  \"..tLines[y]\n                x = x + 2\n                setCursor( x, y )\n                redrawLine(y)\n            end\n        elseif param == keys.pageUp then\n            -- Page Up\n            if not bMenu then\n                -- Move up a page\n                local sx,sy=term.getSize()\n                y=y-sy-1\n                if y<1 then y=1 end\n                x = math.min( x, string.len( tLines[y] ) + 1 )\n                setCursor( x, y )\n            end\n        elseif param == keys.pageDown then\n            -- Page Down\n            if not bMenu then\n                -- Move down a page\n                local sx,sy=term.getSize()\n                if y<#tLines-sy-1 then\n                    y = y+sy-1\n                else\n                    y = #tLines\n                end\n                x = math.min( x, string.len( tLines[y] ) + 1 )\n                setCursor( x, y )\n            end\n        elseif param == keys.home then\n            -- Home\n            if not bMenu then\n                -- Move cursor to the beginning\n                x=1\n                setCursor(x,y)\n            end\n        elseif param == keys[\"end\"] then\n            -- End\n            if not bMenu then\n                -- Move cursor to the end\n                x = string.len( tLines[y] ) + 1\n                setCursor(x,y)\n            end\n        elseif param == keys.left then\n            -- Left\n            if not bMenu then\n                if x > 1 then\n                    -- Move cursor left\n                    x = x - 1\n                elseif x==1 and y>1 then\n                    x = string.len( tLines[y-1] ) + 1\n                    y = y - 1\n                end\n                setCursor( x, y )\n            else\n                -- Move menu left\n                nMenuItem = nMenuItem - 1\n                if nMenuItem < 1 then\n                    nMenuItem = #tMenuItems\n                end\n                redrawMenu()\n            end\n        elseif param == keys.right then\n            -- Right\n            if not bMenu then\n                if x < string.len( tLines[y] ) + 1 then\n                    -- Move cursor right\n                    x = x + 1\n                elseif x==string.len( tLines[y] ) + 1 and y<#tLines then\n                    x = 1\n                    y = y + 1\n                end\n                setCursor( x, y )\n            else\n                -- Move menu right\n                nMenuItem = nMenuItem + 1\n                if nMenuItem > #tMenuItems then\n                    nMenuItem = 1\n                end\n                redrawMenu()\n            end\n        elseif param == keys.delete then\n            -- Delete\n            if not bMenu then\n                if  x < string.len( tLines[y] ) + 1 then\n                    local sLine = tLines[y]\n                    tLines[y] = string.sub(sLine,1,x-1) .. string.sub(sLine,x+1)\n                    redrawLine(y)\n                elseif y<#tLines then\n                    tLines[y] = tLines[y] .. tLines[y+1]\n                    table.remove( tLines, y+1 )\n                    redrawText()\n                    redrawMenu()\n                end\n            end\n        elseif param == keys.backspace then\n            -- Backspace\n            if not bMenu then\n                if x > 1 then\n                    -- Remove character\n                    local sLine = tLines[y]\n                    tLines[y] = string.sub(sLine,1,x-2) .. string.sub(sLine,x)\n                    redrawLine(y)\n            \n                    x = x - 1\n                    setCursor( x, y )\n                elseif y > 1 then\n                    -- Remove newline\n                    local sPrevLen = string.len( tLines[y-1] )\n                    tLines[y-1] = tLines[y-1] .. tLines[y]\n                    table.remove( tLines, y )\n                    redrawText()\n                \n                    x = sPrevLen + 1\n                    y = y - 1\n                    setCursor( x, y )\n                end\n            end\n        elseif param == keys.enter then\n            -- Enter\n            if not bMenu then\n                -- Newline\n                local sLine = tLines[y]\n                local _,spaces=string.find(sLine,\"^[ ]+\")\n                if not spaces then\n                    spaces=0\n                end\n                tLines[y] = string.sub(sLine,1,x-1)\n                table.insert( tLines, y+1, string.rep(' ',spaces)..string.sub(sLine,x) )\n                redrawText()\n            \n                x = spaces+1\n                y = y + 1\n                setCursor( x, y )\n            else\n                -- Menu selection\n                doMenuItem( nMenuItem )\n            end\n        elseif param == keys.leftCtrl or param == keys.rightCtrl then\n            -- Menu toggle\n            bMenu = not bMenu\n            if bMenu then\n                term.setCursorBlink( false )\n                nMenuItem = 1\n            else\n                term.setCursorBlink( true )\n            end\n            redrawMenu()\n        end\n        \n    elseif sEvent == \"char\" then\n        if not bMenu then\n            -- Input text\n            local sLine = tLines[y]\n            tLines[y] = string.sub(sLine,1,x-1) .. param .. string.sub(sLine,x)\n            redrawLine(y)\n        \n            x = x + string.len( param )\n            setCursor( x, y )\n        else\n            -- Select menu items\n            for n,sMenuItem in ipairs( tMenuItems ) do\n                if string.lower(string.sub(sMenuItem,1,1)) == string.lower(param) then\n                    doMenuItem( n )\n                    break\n                end\n            end\n        end\n        \n    elseif sEvent == \"mouse_click\" then\n        if not bMenu then\n            if param == 1 then\n                -- Left click\n                local cx,cy = param2, param3\n                if cy < h then\n                    y = math.min( math.max( scrollY + cy, 1 ), #tLines )\n                    x = math.min( math.max( scrollX + cx, 1 ), string.len( tLines[y] ) + 1 )\n                    setCursor( x, y )\n                end\n            end\n        end\n        \n    elseif sEvent == \"mouse_scroll\" then\n        if not bMenu then\n            if param == -1 then\n                -- Scroll up\n                if scrollY > 0 then\n                    -- Move cursor up\n                    scrollY = scrollY - 1\n                    redrawText()\n                end\n            \n            elseif param == 1 then\n                -- Scroll down\n                local nMaxScroll = #tLines - (h-1)\n                if scrollY < nMaxScroll then\n                    -- Move cursor down\n                    scrollY = scrollY + 1\n                    redrawText()\n                end\n                \n            end\n        end\n    end\nend\n\n-- Cleanup\nterm.clear()\nterm.setCursorBlink( false )\nterm.se\nend\n\nfunction requestObject(url,sN,mode)\n    if not url then error('Incorrect statement!') end\n    if not sN and mode == 'get' then error('Check mode!') end\n    if mode == 'get' then\n        write('Fetching: '..url..'... ')\n        http.request(url)\n        local requesting = true\n        while requesting do\n            local event, url, sourceText = os.pullEvent()\n            if event == \"http_success\" then\n                local respondedText = sourceText.readAll()\n                temp = io.open(sN,'w')\n                temp:write(respondedText)\n                temp:close()\n                print('Successfully saved!')\n                requesting = false\n                return true\n            elseif event == \"http_failure\" then\n                print(\"Fetch failed! Please check values or non-existent project!\")\n                requesting = false\n                return false\n            end\n        end\n    elseif mode == 'view' then\n        write('Fetching: '..url..'... ')\n        http.request(url)\n        local requesting = true\n        while requesting do\n            local event, url, sourceText = os.pullEvent()\n            if event == \"http_success\" then\n                local respondedText = sourceText.readAll()\n                print('Successfully fetched!\\n')\n                temp = io.open('temp','w')\n                temp:write(respondedText)\n                temp:close()\n                edit('temp')\n                fs.delete('temp')\n                requesting = false\n                return true\n            elseif event == \"http_failure\" then\n                print(\"Fetch failed!\")\n                requesting = false\n                return false\n            end\n        end\n    end\nend\n\nfunction compileURL(auth,pro,bran,pat)\n    baseURL = 'https://raw.github.com/'..auth..'/'..pro..'/'..bran..'/'..pat\n    return baseURL\nend\n\nfunction get(auth,reps,bran,paths,sN)\n    if not auth or not reps or not bran or not paths or not sN then error('Attempt to compile nonexistent terms!') end\n    requestObject(compileURL(auth,reps,bran,paths),sN,'get')\nend\n\nfunction view(auth,reps,bran,paths)\n    if not auth or not reps or not bran or not paths then error('Attempt to compile nonexistent terms!') end\n     requestObject(compileURL(auth,reps,bran,paths),nil,'view')\nend\n"]],"start1":13,"start2":13,"length1":104,"length2":19841}]],"length":19854,"saved":false}
{"contributors":[],"silentsave":false,"ts":1373051777678,"patch":[[{"diffs":[[1,"--===GIT API===\n--=============\n--Developed by LNETeam from LNET Technologies\n--Please remove the 'a' from the end of the file before putting it into your API folder\n\n--Usage: git.get(author,repository,branch,path,saveName), git.view(author,repository,branch,path)\n"],[0,"\n\nlocal function edit(fi"]],"start1":0,"start2":0,"length1":24,"length2":289},{"diffs":[[0,"\nterm.se"],[1,"tCursorPos(1,1)"],[0,"\n"],[-1,""],[0,"end\n\nfun"]],"start1":17821,"start2":17821,"length1":17,"length2":32},{"diffs":[[0,"hen\n"],[-1,"        write('Fetching: '..url..'... ')\n"],[0,"    "]],"start1":18024,"start2":18024,"length1":49,"length2":8},{"diffs":[[0,"e()\n"],[-1,"                print('Successfully saved!')\n"],[0,"    "]],"start1":18381,"start2":18381,"length1":53,"length2":8},{"diffs":[[0,"hen\n"],[-1,"                print(\"Fetch failed! Please check values or non-existent project!\")\n"],[0,"    "]],"start1":18492,"start2":18492,"length1":92,"length2":8},{"diffs":[[0,"l()\n"],[-1,"                print('Successfully fetched!\\n')\n"],[0,"    "]],"start1":18903,"start2":18903,"length1":57,"length2":8},{"diffs":[[0,"hen\n"],[-1,"                print(\"Fetch failed!\")\n"],[0,"    "]],"start1":19191,"start2":19191,"length1":47,"length2":8},{"diffs":[[0," end\n   "],[1," statusCode ="],[0," request"]],"start1":19592,"start2":19592,"length1":16,"length2":29},{"diffs":[[0,",'get')\n"],[1,"    return statusCode\n"],[0,"end\n\nfun"]],"start1":19663,"start2":19663,"length1":16,"length2":38},{"diffs":[[0,"!') end\n    "],[1,"statusCode ="],[0," requestObje"]],"start1":19835,"start2":19835,"length1":24,"length2":36},{"diffs":[[0,"'view')\n"],[1,"    return statusCode\n"],[0,"end\n"]],"start1":19911,"start2":19911,"length1":12,"length2":34}]],"length":19945,"saved":false}
{"ts":1373051953460,"patch":[[{"diffs":[[0,"gs[1] = "],[-1,"path"],[1,"file"],[0,"\n\n-- Err"]],"start1":300,"start2":300,"length1":20,"length2":20}]],"length":19945,"saved":false}
{"ts":1373052109711,"patch":[[{"diffs":[[0,"t(file)\n"],[1,"    tArgs = {}\n"],[0,"    tArg"]],"start1":285,"start2":285,"length1":16,"length2":31}]],"length":19960,"saved":false}
{"ts":1373053555238,"patch":[[{"diffs":[[0,"le)\n"],[-1,"    tArgs = {}\n    tArgs[1] = file\n\n"],[0,"-- E"]],"start1":289,"start2":289,"length1":44,"length2":8},{"diffs":[[0,"h = "],[-1,"shell.resolve( tArgs[1] )"],[1,"'temp'"],[0,"\n\nlo"]],"start1":321,"start2":321,"length1":33,"length2":14}]],"length":19905,"saved":false}
